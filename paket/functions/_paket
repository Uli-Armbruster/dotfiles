#compdef paket.exe

# Zsh completion script for Paket (https://github.com/fsprojects/Paket/).
#
# This script is based on the excellent git complection in zsh. Many thanks
# to its authors!

_paket() {
  echo $service > /tmp/_paket

  local curcontext=$curcontext state line ret=1
  local -A opt_args

  # Currently not implemented:
  # ! means that if these options were specified right after paket, do not
  # offer them as completions for the command.
  # E.g. paket --verbose install<tab> won't show verbose again
  local -a global_options
  global_options=(
    '(-v --verbose)'{-v,--verbose}'[Enable verbose console output for the paket process]'
    '(--log-file)'--log-file'[Specify a log file for the paket process]:log file:_files'
    '(-s --silent)'{-s,--silent}'[Suppress console output for the paket process]'
    '(- :)'--help'[Display help]'
  )

  local -a keep_options
  keep_options=(
    '(--keep-major --keep-minor --keep-patch)'--keep-major'[Allow only updates that are not changing the major version of the NuGet packages]'
    '(--keep-major --keep-minor --keep-patch)'--keep-minor'[Allow only updates that are not changing the minor version of the NuGet packages]'
    '(--keep-major --keep-minor --keep-patch)'--keep-patch'[Allow only updates that are not changing the patch version of the NuGet packages]'
  )

  local -a binding_redirects_options
  binding_redirects_options=(
    '(--redirects)'--redirects'[Create binding redirects for the NuGet packages]'
    '(--clean-redirects)'--clean-redirects'[Remove all binding redirects that are not specified by paket]'
    '(--createnewbindingfiles)'--createnewbindingfiles'[Create binding redirect files if needed]'
  )

  local -a download_options
  download_options=(
    '(-f --force)'{-f,--force}'[Force the download and reinstallation of all packages]'
    '(--touch-affected-refs)'--touch-affected-refs'[Touch project files referencing packages which are affected, to help incremental build tools detecting the change]'
    '(--only-referenced)'--only-referenced'[Only install packages that are referenced in paket.references files, instead of all packages in paket.dependencies]' \
  )

  # --verbose, --log-file and --silent (see above)
  #   These can appear as the first option, optionally followed by a command.
  #
  # --version and --help (see above)
  #   No more options are allowed afterwards.
  #
  # command
  #   Does not start with dash.
  #
  # option-or-argument
  #   This is the "rest" argument.
  #
  # For more information, see http://zsh.sourceforge.net/Doc/Release/Completion-System.html
  # and search for "Each of the forms above may be preceded by a list in
  # parentheses of option names and argument numbers".
  _arguments -C \
    $global_options \
    '(- :)'--version'[Display the version]' \
    '(-): :->command' \
    '(-)*:: :->option-or-argument' \
  && return

  typeset -p state >> /tmp/_paket

  case "$state" in
    (command)
      _paket_commands && ret=0
      ;;

    (option-or-argument)
      curcontext=${curcontext%:*:*}:paket-$words[1]:
      typeset -p curcontext >> /tmp/_paket
      typeset -p words >> /tmp/_paket

      if ! _call_function ret _paket-$words[1]; then
        _message "paket command '$words[1]' is not implemented, please contact @agross"

        if zstyle -T :completion:$curcontext: use-fallback; then
          _default && ret=0
        fi
      fi
      ;;
  esac

  return ret
}

#(( $+functions[_paket-add] )) ||
_paket-add() {
  local curcontext=$curcontext state line ret=1
  declare -A opt_args

  local -a args
  args=(
    $global_options
    $keep_options
    $binding_redirects_options
    $download_options
    '(--interactive -i)'{--interactive,-i}"[Ask for every project whether to add the package to the projects\'s paket.references file]"
    '(--no-install)'--no-install'[Skip install process (patching of project files) after the generation of paket.lock file]'
  )

  _arguments -C \
    $args \
    ': :->command' \
    '*:: :->option-or-argument' \
  && ret=0

  case $state in
    (command)
      local -a commands

      commands=(
        group:'Add the package to the given group. Default: Main group'
        nuget:'NuGet package ID'
        project:'Add the package to a single project only'
        version:'Version of the package'
      )

      _describe -t commands command commands && ret=0
      ;;

    (option-or-argument)
      curcontext=${curcontext%:*}-$line[1]:

      case $line[1] in
        (group)
          _arguments \
            ': :_paket_groups' \
            $args \
          && ret=0
          ;;

        (nuget)
          _arguments \
            ':package name:' \
            $args \
          && ret=0
          ;;

        (project)
          _arguments \
            ':project:_path_files -g "**/*.??proj"' \
            $args \
          && ret=0
          ;;

        (version)
          _arguments \
            ':version:' \
            $args \
          && ret=0
          ;;
      esac
      ;;
  esac

  return ret
}

#(( $+functions[_paket-install] )) ||
_paket-install() {
  _arguments \
    $global_options \
    $keep_options \
    $binding_redirects_options \
    $download_options
}

#(( $+functions[_paket-restore] )) ||
_paket-restore() {
  local curcontext=$curcontext state line ret=1
  declare -A opt_args

  local -a args
  args=(
    $global_options
    $download_options
    '(--ignore-checks)'--ignore-checks'[Skips the test if paket.dependencies and paket.lock are in sync]'
    '(--references-files --only-referenced)'--references-files'[Restore all packages from the given paket.references files. This implies --only-referenced]'
  )

  _arguments -C \
    $args \
    ': :->command' \
    '*:: :->option-or-argument' \
  && ret=0

  case $state in
    (command)
      local -a commands

      commands=(
        group:'Restore a single group'
      )

      _describe -t commands command commands && ret=0
      ;;

    (option-or-argument)
      curcontext=${curcontext%:*}-$line[1]:

      if [[ $line[1] == 'group' ]]; then
        _arguments \
          ': :_paket_groups' \
          $args \
        && ret=0
      fi
      ;;
  esac

  return ret
}

(( $+functions[_paket_commands] )) ||
_paket_commands() {
  local -a types
  types=(
    dependency
    inspection
    nuget
    misc
  )

  for type in $types; do
    local -a $type
  done

  dependency=(
    add:'Adds a new package to your paket.dependencies file'
    install:'Download the dependencies specified by the paket.dependencies or paket.lock file into the packages/ directory and update projects'
    outdated:'Lists all dependencies that have newer versions available'
    remove:'Removes a package from your paket.dependencies file and all paket.references files'
    restore:'Download the dependencies specified by the paket.lock file into the packages/ directory'
    simplify:'Simplifies your paket.dependencies file by removing transitive dependencies'
    update:'Update one or all dependencies to their latest version and update projects'
  )

  inspection=(
    find-packages:'Allows to search for packages'
    find-package-versions:'Allows to search for package versions'
    find-refs:'Finds all project files that have the given NuGet packages installed'
    show-groups:'Shows all groups'
    show-installed-packages:'Shows all installed top-level packages'
  )

  nuget=(
    pack:'Packs all paket.template files within this repository'
    push:'Pushes the given .nupkg file'
  )

  misc=(
    auto-restore:'Enables or disables automatic package restore in Visual Studio during the build process'
    clear-cache:'Clears the NuGet and git cache folders'
    config:'Allows to store global configuration values like NuGet credentials'
    convert-from-nuget:'Converts from using NuGet to paket'
    generate-include-scripts:'Allows to generate C# and F# include scripts which references installed packages in a interactive environment like F# Interactive or ScriptCS.'
    init:'Creates an empty paket.dependencies file in the working directory'
  )

  for type in $types; do
    local -a all_commands ${type}_commands

    # Remove everything after the colon of the command definition above.
    set -A ${type}_commands ${(P)type%%:*}
    # Copy command list to all_commands.
    all_commands+=(${(P)${:-${type}_commands}})
  done

  # To get the length of the longest matching command, filter the list of
  # commands down to the prefix the user typed.
  # Get applicable matchers.
  local expl
  _description '' expl ''
  local -a all_matching_commands
  compadd "$expl[@]" -O all_matching_commands -a all_commands
  # Length of longest match.
  longest_match=${#${(O)all_matching_commands//?/.}[1]}

  # Verbose/long display requested?
  local -a disp
  if zstyle -T ":completion:${curcontext}:" verbose; then
    disp=(-ld '${type}_desc')
  fi

  local -a alternatives
  for type in $types; do
    local -a ${type}_desc

    # Write description:
    #   1. command padded with spaces up to longest_match
    #   2. ' -- '
    #   3. description, trimmed if longer than screen width
    set -A ${type}_desc \
      ${${(Pr.COLUMNS-1.)type/(#s)(#m)[^:]##:/${(r.longest_match.)MATCH[1,-2]} -- }%% #}
      #"foo bar $longest_match"

    alternatives+=("${type}:$type command:compadd ${(e)disp} -a ${type}_commands")
  done

  _alternative $alternatives

# echo > /tmp/_paket
# typeset -p all_commands >> /tmp/_paket
# echo --- >> /tmp/_paket
# typeset -p all_matching_commands >> /tmp/_paket
# echo --- >> /tmp/_paket
# typeset -p alternatives >> /tmp/_paket
# echo --- >> /tmp/_paket
# typeset -p misc_desc >> /tmp/_paket
# echo --- >> /tmp/_paket
# typeset -p misc_commands >> /tmp/_paket
}

#(( $+functions[_paket_groups] )) ||
_paket_groups() {
  local -a groups
  local output exit_status

  # Replace CR, in case we're running on Windows.
  output="${$(_call_program groups "$(_paket_executable)" show-groups 2> /dev/null)//$'\r'/}"
  _paket_command_successful $? || return 1

  # Split output on \n, creating array of lines.
  groups=(${${(f)output}})

  # Remove first and last line (paket version and time taken), sort elements.
  groups=(${(i)groups[2,-2]})

  _wanted paket-groups expl 'paket group' compadd $groups
}

#(( $+functions[_paket_command_successful] )) ||
_paket_command_successful () {
  if (( ${#*:#0} > 0 )); then
    _message "paket invocation failed with exit status $1"
    return 1
  fi
  return 0
}

#(( $+functions[_paket_executable] )) ||
_paket_executable() {
  local -a locations
  locations=(
    ./.paket/$service
    ./$service
  )

  local location
  for location in $locations; do
    [[ -f "$location" ]] && echo $location && return
  done

  return 1
}

_paket "$@"

# vim: ft=zsh sw=2 ts=2 et
